create project 
    cli: flutter create <name all lowercase> หรือถ้าต้องการแบ่งคำให้แบ่งด้วย _
    or 
    cmd shift p -> flutter new project 


structure 
    lib/main.dart นี่คือไฟล์ main ที่เราจะเริ่มศึกษา 


luanch emulator 
    ใช้ xcode เพื่อ emulate ios device
    1. download xcode 
    2. open xcode 
    3. คลิกที่ขวาบนจอ mac ตรง xcode
    4. เลือก open developer tools 
    5. เลือก simulator มันจะ run iphone ขึ้นมา

ตอน run ไปที่ lib/main.dart 
fn f5 จะทำการ run project ขึ้นมา 
หรือ flutter run 
    
structure 
    lib 
        เก็บไฟล์ที่แยกหน้าแอพต่างๆ ที่มีนามสกุล .dart เข่น main.dart 
    pubspec.yaml
        สำหรับการตั้งค่าโปรเจค หรือใช้งาน lib ต่างๆ (คล้ายๆ go.mod)
    android, ios 
        จัดเก็บโปรเจคของ application แต่ละระบบเอาไว้ 
    
หลังจาก build ไปแล้ว สามารถเปลี่ยนชื่อ app ได้ 
    android 
        ไปที่ android -> app -> src -> main -> AndroidManifest.xml 
        กำหนดชื่อ app ใหม่ใน android:label
        build 

    ios 

change icon 
    android
        android -> app -> src -> main -> res -> พวก mipmap คือ icon ทั้งหมด แต่ขนาดต่างกัน
    

Widget 
    คือแนวคิดในการแบ่ง ui เป็นส่วนๆ เข่น ปุ่ม, ข้อความ เป็นต้น 
    โดย widget แต่ละตัว จะมี properties หลากหลาย เข่น สี ขอบ ส่วนโค้ง 

Widget พื้นฐานที่มีใน dart 
    Text Widget สำหรับแสดงข้อความ 
    RaisedButton สำหรับการจัดการปุ่ม 
    Row, Column สำหรับสร้าง layout (เค้าโครงหน้าแอพ) แบบแนวตั้งและแนวนอน 
    Stak สร้าง layout แบบซ้อนทับ หรือเรียงลำดับ 
    Container กล่องที่รวบรวม widget ต่างๆ 

ใน flutter จะมี widget ที่ชื่อว่า material design 

==============

import 'package:flutter/material.dart'; //ต้อง import มา เพื่อใช้งาน material

void main() {
  runApp(app) // ภายใต้ runApp ต้องเป็น Widget ที่เราต้องการให้ทำงาน 
}

ex.
    MaterialApp จะใช้ในการควบคุมการแสดงผลในหน้าแอพ ต้องประกาศ

    void main() {
        var app = MaterialApp(
            title: "My App",
            home: Text("This My App"),
        );
        runApp(app);
    }


*** จะเห็นว่า app ยังไม่มีเค้าโครงเลย ***


Scaffold 
    เป็น widget หน้าต่างสำเร็จรูป สำหรับการจัด layout หรือโครงสร้างของหน้าแอพ มีการคำนวณระยะห่างของ app กับ emulator ให้อัตโนมัติ 

    runApp(MaterialApp(
        home: Scaffold( // home คือจะให้แสดงผลอะไรในหน้า home ก็ใส่ widget เข้าไป ในที่นี้ใส่ widget scaffold เพื่อให้สามารถจัดการหน้าแอพภายใต้ scaffold ต่อไปได้
            title: "Hello",
            appBar: AppBar(title: Text("Text")),
            body:Text("Hello Flutter")
        ),
        theme: ThemeData(primarySwatch:Colors.green) // เปลี่ยนธีมแอพ
    ))

การสร้าง widget ขึ้นมาใช้เอง
    สามารถ สร้างได้ 2 ประเภท 
    - Stateless Widget 
        เป็น widget ที่ไม่สามารถเปลี่ยนแปลงค่าได้ ใช้สำหรับสร้าง Widget แบบคงที่ เช่น Text, icon เป็นต้น 
    - Stateful widget 
        เป็น widget ที่สามารถเปลี่ยนแปลงค่าได้ หรือทำงานได้หลาย State เช่น Checkbox, Slider, TextField เป็นต้น 
        คือมีการเปลี่ยนแปลงข้อมูลได้ในขณะที่ run app อยู่

Stateless Widget
    ให้พิมพ์​ stl จะมี suggest ขึ้นมา แนะนำคำสั่ง Flutter Create Stateless Widget ประมาณนี้ ก็เลือกไป จะมี template ขึ้นมาให้เรา


    ex.
        import 'package:flutter/src/widgets/framework.dart';
        import 'package:flutter/src/widgets/placeholder.dart';

        class MyWidget1 extends StatelessWidget {
        const MyWidget1({super.key});

        @override
        Widget build(BuildContext context) { // return ค่าเป็น widget 
            return Container(); // default อาจจะเป็นตัวอื่น ในที่นี้เปลี่ยนเป็น Container เพื่อใช้งานสำหรับแอพ  
        }
        }

    ทำการสร้าง myApp.dart พร้อมสร้าง stateless widget 

        class MyApp extends StatelessWidget {
        const MyApp({super.key});

        @override
        Widget build(BuildContext context) {
            return MaterialApp( // ทำการ return MaterialApp ออกไป 
            debugShowCheckedModeBanner: false, // remove Debug in top right
            theme: ThemeData(primarySwatch: Colors.green),
            title: "My App",
            home: Scaffold(
                appBar: AppBar(
                title: Text("My App"),
                ),
                body: Text("Body Part"),
            ));
        }
        }

    main.dart 
        void main() {
            const app = MyApp(); //เรียกใช้ MyApp ที่แยกออกไปเป็น widget class
            runApp(app);
        }

Center Widget 
    เป็น widget ที่ครอบ widget อื่นๆ ทำให้ widget ที่ถูกครอบ อยู่กลางหน้าจอ (x,y) = (0,0)

    ex. 
        Scaffold(
            body: Center(
                child: Text("test")
            )
        )

Text วิธีการเพิ่มขนาดและเปลี่ยนสี
    Text(
        "text", 
        style: TextStyle(
            fontSize: 30,
            color: Colors.Blue,
            ...
        )
    )


***** Tips *****
    หากต้องการ child มากกว่า 1 ก็ให้นำ widget ที่รองรับ child มากกว่า 1 เข้ามาใช้ เช่น column, row 
    Scaffold(
            appBar: AppBar(
              title: Text("My App"),
            ),
            body: Center(
              child: Column( //เนื่องจาก center รับ child แค่ตัวเดียว แต่อยากได้ child มากกว่า 1 เลยต้องนำ column มาใช้ โดยใน column จะมี children ใ้ห้ใช้ เปรียบเสมือน child
              // แต่พอเป็น column จุด start ของ column จะเป็น บนสุด จะไม่ใช่กลางจอ แต่ x ยัง = 0 อยู่ แต่ y จะไม่ใช่ จะกลายเป็นบนสุด
                children: [
                  Text(
                    "Body Part",
                    style: TextStyle(
                        fontSize: 30,
                        color: Colors.green,
                        fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            )));


การนำภาพเข้ามาแสดงผล
    Image
        Image(
            image: NetworkImage(
            "https://images.unsplash.com/photo-1681673211977-2d3274d07ff9?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwzfHx8ZW58MHx8fHw%3D&auto=format&fit=crop&w=500&q=60",
            ),
            width: 400, // เนื่องจากหน่วยเป็น double ไม่มีหน่วย px, %, ... เหมือนกับ css ทำให้เวลาที่ตัองทำ responsive ก็อาจจะต้องคำนวณกับขนาดหน้าจอ ความกว้าง ความยาว ด้วย 
            height: 400, // เนื่องจากหน่วยเป็น double ไม่มีหน่วย px, %, ... เหมือนกับ css ทำให้เวลาที่ตัองทำ responsive ก็อาจจะต้องคำนวณกับขนาดหน้าจอ ความกว้าง ความยาว ด้วย 
        )

column
    เป็น widget ที่รับเอา Widget แื่นๆ มาจัดเรียงในแนวตั้ง หรือในแนวดิ่ง 

    body: Center(
        child: Column(
            mainAxisAlignment: MainAxisAlignment.center, // ถ้าไม่ระบุแบบนี้ default จะเป็น statrt คือชิดข้างบน properties จะคล้ายๆกับ flex box ก็จะมีพวก space between, space around หรือ อะไรต่างๆคล้ายๆกัน
            children: [
                widget1, //อาจจะเอา widget ที่สร้างเองขึ้นมา มาใส่ก็ได้
                widget2, //อาจจะเอา widget ที่สร้างเองขึ้นมา มาใส่ก็ได้
                widget3, //อาจจะเอา widget ที่สร้างเองขึ้นมา มาใส่ก็ได้
            ]
        )
    )

Stateful Widget 
    - widget ที่สามารถเปลี่ยนแปลงค่าได้ หรือทำงานหลาย state โดย state คือตัวแปรหรือข้อมูล ที่ใช้ควบคุมการทำงาน ของ แอพให้โต้ตอบกับ user ได้ 
    มีการใช้คพสั่ง setState() เพื่อบอกว่าในแอพมีบางอย่างเปลี่ยนแปลง เกิดขึ้นที่ State สามาถทำให้ข้อมูลในหน้าแอพเปลี่ยนแปลงและทำงานต่อเนื่องได้ โดยที่
    ไม่ต้อง build หรือ restart app (เปลี่ยนแปลงหน้าตาได้)
    - state สำหรับ ควบคุมการทำงานของแอพตามที่ต้องการ เช่น อัพเดตการทำงานของหน้าจอ หรือ widget ผ่าน state นั่นเอง 
    - widget หน้าตาของแอพ

    - มีการทำปฏิสัมพันธ์กับ user เช่น checkbox, input text, กดปุ่มแล้วหน้าจอเปลี่ยนค่า เช่น ปุ่ม + ที่มีมาให้ตอน initial app
        *** แต่ถ้า stateless คือ เหมือน static เช่น การ fix หัวขัอ หรืออะไรต่างๆ ***

Button & Event 
    floatinActionButtonFloatingActionButton(
        onPressed:(){

        },
        child:Icon(Iconds.add) หรือ 
        chile: Text("my text")
    )

    class MyHomePage extends StatefulWidget {
    const MyHomePage({super.key});

    @override
    State<MyHomePage> createState() => _MyHomePageState();
    }

    class _MyHomePageState extends State<MyHomePage> {
    int _num = 0; // สร้่าง state
    @override
    Widget build(BuildContext context) {
        // สร้าง state
        return Scaffold(
            appBar: AppBar(
            title: Text("My App"),
            ),
            body: Center(
            child: Column(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                Text("This is Current Num: $_num"),
                FloatingActionButton(
                    onPressed: () => {
                    setState(
                        () => {this._num++},
                    ) // เมื่อใช้คำสั่ง setState และเมื่อมีการเปลี่ยนแปลงตัวแปร มันจะวิ่งไปหาว่า ตัวแปรที่เปลี่ยนแปลง ถูกเรียกใช้ตรงไหนบ้าง ก็จะเปลี่ยนแปลงทั้งหมดทุกจุดตามกันไปด้วย
                    }, // หากจะเรียกใช้ function ก็เรียกแค่ชื่อ function ได้เลย เป็น onPressed:AddNumber
                    child: Icon(Icons.plus_one),
                )
                ],
            ),
            ));
    }
    // หรือ เขียนแยก function ก็ได้ 

    void AddNumber() {
        setState(() {
        this._num++;
        });
      }
    }
 


Listview Widget
    คือ widget ที่มีการแสดงผลเป็นรายการ เมื่อมีรายการมากๆ เกินพื้นที่ของจอ สามารถ scroll down หรือ up เพื่อดูรายการก่อนหน้าได้ 

    List คือ โครงสร้างข้อมูลที่จัดการเกี่ยวกับกลุ่มข้อมูล 
    Listview จะใช้ในกรณีที่แสดงรายการขนาดเล็ก (4-10 รายการ)
    Listview.builder ใช้ในกรณัืที่มีการแสดงรายการจำนวนมาก โดยระบุจำนวนผ่านรายการ properties ชื่อ itemcount *** ถ้าไม่กำหนดขนาด จะได้ขนาดที่ไม่่มีสิ้นสุด
    ListTile กำหนดรายละเอียดต่างๆของ list แต่ละรายการ เช่น หัวข้อ(title), หัวข้อย่อย (subtitle)


การนำภาพ internal เข้ามาใช้ 
    1. ไปที่ pubspec.yaml 
        ไปที่ comment 
        # To add assets to your application, add an assets section, like this:
        # assets:
        #   - images/a_dot_burr.jpeg
        #   - images/a_dot_ham.jpeg

        ให้พิมพ์คำสั่งเพิ่ม 
        assets:
            - <path to your file> // เป็น path ของไฟล์ในโปรเจค โดยมองจากชั้น root ต้องเติม / ท้าย folder สุดท้ายด้วย

ใน ListTile มี properties ชื่อว่า  leading เพื่อนำรูปภาพมาแสดง 
    ListTile(
        leading: Image.assets(<image path>), // สามารถใชั Image(image: NetworkImage(... ได้
        ...
    )

ใน ListTile มี onTap คือ event ให้ใช้ โดย value จะรับเป็น function

        ListTile(
            leading: MyAppImg(
                imageUrl: menus[index].imageUrl,
                width: 100,
                height: 100),
            title: Text("${menus[index].name}"),
            subtitle: Text("ราคา: ${menus[index].price} บาท"),
            onTap: () => {
            print(menus[index].name),
            print(menus[index].price),
            },
        )

Container Widget 
    - widget ที่ใช้กำหนดพื้นที่ สามารถกำหนด รูปร่าง ขนาด หรือจัดว่งตำแหน่ง 
    รวมไปถึงการกำหนดลวดลายและตกแต่ง ด้วยสีให้สวยงามได้ ปกติ container จะไม่แสดงผลให้เห็น 
    เราต้องกำหนดความสูงลงไป และ ขนาดของ container ก็จะขยายเต็มพื้นที่ ใช้ในการจัดวาง UI ให้แสดงผลเหมาะกับหน้าจอ

    BoxDecoration 
        - สำหรับกำหนดรูปร่างของ container เช่น สี ลักษณะรูปร่างของ container เป็นต้น 
    Padding 
        - กำหนดระยะห่างของ widget ออกจากขอบของ layout เช่น ขอบหน้าจอ
    Column 
        - ใช้แสดง widget ย่อย (child) ในแนวตั้ง 
    Row 
        - ใช้แสดง widget ย่อย (child) ในแนวนอน properties คล้ายกับ column ต่างกันที่การแสดงผล 
    Expanded 
        - ใช้ขยายความสูงของ widget ย่อย (child) ที่ต้องการ โดยทำการจัดสรรพื้นที่ของ Widget ย่อย (child)ให้เต็มพื้นที่ 
        โดยดูจากพื้นที่ว่างที่เหลือในหน้าจอ (คล้ายๆกับ flexbox ใน css) และมีการกำหนดพื้นที่ผ่าน flex properties 


Padding 

body: Padding(
          padding: const EdgeInsets.all(
              8.0), // ทำให้มี space จาก ขอบ layout ทุกด้าน 8.0 (required field padding)
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround, **** ปัญหา คือ ถ้าไม่ใส่ตรงนี้ container ก็จะติดกัน
            children: [
              Container(
                padding: const EdgeInsets.all(
                    10), // ทำให้ใน layout มีขอบด้านใน 10 ทำให้เนืื้อหาด้านในก็จะห่างออกจากขอบ
                // สร้าง container
                decoration: BoxDecoration(
                    color: Colors.blueAccent,
                    borderRadius: BorderRadius.circular(
                        10)), // ระบุคุณสมบัติของกล่อง container เช่น สี, โค้ง, ... (ยิ่ง เลข circular เยอะ ก็ยิ่งโค้งเยอะ)
                height: 150,
                child: Row(
                  children: [
                    Text("Balance: ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                    Text("99999999999 Baht ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.all(
                    10), // ทำให้ใน layout มีขอบด้านใน 10 ทำให้เนืื้อหาด้านในก็จะห่างออกจากขอบ
                // สร้าง container อยากได้หลายกล่องก็เพิ่ม container เข้าไปอีก
                decoration: BoxDecoration(
                    color: Colors.green.shade500,
                    borderRadius: BorderRadius.circular(
                        10)), // ระบุคุณสมบัติของกล่อง container เช่น สี, โค้ง, ... (ยิ่ง เลข circular เยอะ ก็ยิ่งโค้งเยอะ)
                height: 150,
                child: Row(
                  children: [
                    Text("Income: ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                    Text("99999999999 Baht ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.all(
                    10), // ทำให้ใน layout มีขอบด้านใน 10 ทำให้เนืื้อหาด้านในก็จะห่างออกจากขอบ

                // สร้าง container อยากได้หลายกล่องก็เพิ่ม container เข้าไปอีก
                decoration: BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.circular(
                        10)), // ระบุคุณสมบัติของกล่อง container เช่น สี, โค้ง, ... (ยิ่ง เลข circular เยอะ ก็ยิ่งโค้งเยอะ)
                height: 150,
                child: Row(
                  children: [
                    Text("Outcome: ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                    Text("15000 Baht ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold)),
                  ],
                ),
              ),
            ],
          ),
        ));


Expanded
    Container(
            padding: const EdgeInsets.all(
                10), // ทำให้ใน layout มีขอบด้านใน 10 ทำให้เนืื้อหาด้านในก็จะห่างออกจากขอบ

            // สร้าง container อยากได้หลายกล่องก็เพิ่ม container เข้าไปอีก
            decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(
                    10)), // ระบุคุณสมบัติของกล่อง container เช่น สี, โค้ง, ... (ยิ่ง เลข circular เยอะ ก็ยิ่งโค้งเยอะ)
            height: 150,
            child: Row(
                children: [
                Text("Outcome: ",
                    style: TextStyle(
                        fontSize: 20,
                        color: Colors.white,
                        fontWeight: FontWeight.bold)),
                Expanded( // เพื่อเป็นการบอกว่า widget นี้สามารถขยายได้ เป็นระยะเท่ากับพื้นที่ที่เหลือ
                    child: Text("15000 Baht ",
                        style: TextStyle(
                            fontSize: 20,
                            color: Colors.white,
                            fontWeight: FontWeight.bold),
                        textAlign: TextAlign.right),
                )
                ],
            ),
            ),

SizedBox 
    - เป็นการสร้างกล่องเปล่า 
    - ต้องกำหนดความสูงด้วย 
    - แทรกต่อจาก container แต่ละตัว 
        Container(
            ...
        ),
        SizedBox(height: 5), // จะเกิดกล่องเปล่าๆขึ้นมา ความสูงเท่ากับที่กำหนด
        Container(
            ...
        ),
        ....

ติดตั้ง package 
    flutter pub add <package name>
    flutter pub add intl

    Text('${NumberFormat("#,###.##").format(money)}')  //NumberFormat เป็น class ของ intl ทำการ set format ของตัวเลข # คือ บอกว่า เป็นเลขอะไรก็ได้ money ต้องรับค่าเป็น double หรือ int 

Stateful Lifecycle 
    initState() คือ method ที่ถูกเรียกให้ทำงาน ครั้งเดียวหลังจากที่ State ถูกสร้างเรียบร้อยแล้ว (หรือ widget ถูกสร้างขึ้นมาแล้ว) สามารถที่จะเปลี่ยนแปลงข้อมูลของ widget ได้ 
    คือทำงานตอนที่ build app แต่หาก state มีการเปลี่ยนแปลง มันจะไม่ทำงานแล้ว จะให้ build ทำงานแทน
    *** เป็น method แรกที่ทำงาน ถ้าอยากจะให้ทำงานอะไรก่อน ก็อยู่ที่นี่เลย เช่นการดึงข้อมูลเพื่อมาเตรียมแสดงผล เช่น ดึงข้อมูลการเงินมา เก็บไว้ พอ เข้า build ก็นำไป display เลย

    build() คือ method ที่ใช้ในการสร้าง widget หรือ widget tree ของ application ถ้าต้องการให้ widget ของ application มีหน้าตาแบบใด ก็เขียนใน method build 
    ซึ่ง build จะถูกเรียกใช้งานเมื่อมีการเปลี่ยนแปลงของข้อมูลใน state โดยทำงานผ่าน method setState *** หลังจากที่ initState() ทำงานเสร็จแล้ว ก็จะมาทำงานต่อที่ build เป็น method ที่ 2
    ** เมื่อตัวแปรที่ประกาศ มีการเปลี่ยนแปลง (SetState()) ก็จะเรียก build ทุกครั้ง

    dispose() คือ method ที่จะถูกเรียกใช้เมื่อ widget หรือ state หายไปจากหน้าแอพ หรือให้หยุดทำงานและนำออกจากระบบ


Asynchronous
    ใน flutter มีการทำงานไปเรื่อยๆ โดยที่ไม่ต้องรอ function ก่อนหน้าทำเสร็จก่อน 
    หมายถึง สามารถทำงาน function ถัดไป และกลับมาทำ function ที่ข้ามไปได้

    จะมี 2 ประเภท 
        Synchronous 
            คือการทำงานตามลำดับ สมมติมีงาน A และงาน B โดยจะให้เริ่มทำงานใน A ให้เสร็จก่อน จนกระทั่งงาน A เสร็จ ค่อยทำงาน B 
        Asynchronous (non-blocking)
            คืิอการทำงานที่สามารถไปทำงานอื่นได้ แล้วค่อยย้อนกลับมาทำงานเก่า เช่น สามารถทำงาน A และ B พร้อมๆกันได้ โดยที่ไม่ต้องรอให้ A เสร็จ 
    ใน Flutter มี function 
        - Future 
            - หมายถึง object หรือข้อมูลที่ได้จากการทำงานในรูปแบบ Asynchronous หรือความหมายคือ การนำค่าที่จะเกิดขึ้นฝนอนาคตมาใช้งาน 
            ซึ่งจะทำการเช็คข้อมูลที่เกิดขึ้นผ่าน State เช่น complated, incomplated 

            การประกาศ 

                Future <return type> <ชื่อ Future> async {
                    await ...); //await คือรอให้บรรทัดนี้ทำงานจนเสร็จ ใช้งานภายใต้ async
                }
            case study 
                โจทย์ จำลองการดึงข้อมูลผู้ใช้จาก DB 
                    - เริ่มดึง 
                    - หน่วงเวลา 10 วิ 
                    - แสดงผล 
                    - ทำงานอย่างอื่นต่อไป 
            
            แบบไม่ใช้ Future 

                void main() {
                    print(loginUser());
                }

                List<String> loginUser() {
                    List<String> users = getUserFromDB();
                    return users;
                }

                List<String> getUserFromDB() {
                    return ["Thanachot", "Arm"];
                }
            
            แบบใช้ Future 

            void main() async { // void ไม่ต้องประกาศ Future ถูกแล้ว แต่ถ้าไม่ใช้ void จะต้องประกาศ future 
                print(await loginUserAsync());
                print("doing another task...");
            }

            // ต้องระบุ Future ที่ function ด้วย เพื่อให้ code รอค่าที่จะมาจาก function getFutureUser ที่เป็น asynchronous  ที่ return Future value ได้
            Future<List<String>> loginUserAsync() async {
            return await getFutureUser();
            }

            // ข้อมูลที่จะได้ในอนาคต ต้องรอ 10 วิ
            Future<List<String>> getFutureUser() {
            List<String> users = [
                "Thanachot Tesjaroen",
                "Patcharakorn sukson",
            ];
            // return Future.value(users); // การ return แบบปกติ ให้ตรงกับ type ที่ defined
            return Future.delayed(Duration(seconds: 10), () => users); // delay 10 seconds
            }


https://exchangeratesapi.io/ เป็น openAPI สำหรับดึง อัตราแลกเปลี่ยน
ตอนนี้ต้อง subscribe เพื่อเอา api key ก็เลือก plan 0 ไปก็ได้ 


https://apipheny.io/free-api/ => web ที่รวม free api 


    https://official-joke-api.appspot.com/random_joke free api without key 

    http เป็น package สำหรับใช้งานการ request http 
        flutter pub add http 
            เนื่องจากต้องมีการดึง value มา set ก่อน จึงต้องใช้ stateful เพื่อดึง ข้อมูลมา set ที่ initState 

    @override
    void initState() {
        super.initState();
        getLatedExchangeRate();
    }

    Future<void> getLatedExchangeRate() async {
        var url = Uri.http("official-joke-api.appspot.com", "/random_joke",
            {'q': '{http}'});
        var response = await http.get(url);
        print(response.body);
    }

https://quicktype.io/  เป็น web ที่ใช้ในการแปลง json เป็น code ของภาษาต่างๆ 
    - open quicktype
    - เลือก JSON ตรงฝั่งซ้าย และวาง json 
    - ฝั่งขวา เลือกภาษา Dart และ เลือก switch Make all properties optional ทำให้เมื่อในอนาคตถ้า json มีการปรับ structure จะไม่กระทบกับแอพเรา 
    - พอได้ code ก็ copy มาสร้างไฟล์เลย .dart


Null Coalescing มี 3 วิธี
    หากตัวแปรมีค่า null จะเปลี่ยนเป็นค่า เริ่มต้นแทน 
        String name; 
        print(name??"Thanachot"); // เมื่อ name เป็น null จะใช้เป็น Thanachot แทน แต่ใช้ได้ครั้งเดียว เพราะใช้ใน print เท่านั้น

    หากตัวแปรมีค่า null จริงๆ จะให้กำหนดค่า default เข้าไปได้เลย 
        String name;
        name??="Thanachot"; // หาก name เป็น null จะกำหนดค่าเป็น Thanachot แทน 
        print(name);
    
    เช็ค object  ว่าเป็น null หรือไม่ ถ้าเป็น null จะข้ามไป 
    class Employee {
        void showData(){
            print("Hello Emp");
        }
    }
    // แบบเต็ม
    Employee emp; // ทำแบบนี้จะเป็น null เพราะไม่ได้ assign value คือไม่ได้ new instant เลยไม่เกิดเป็น object ซึ่งถ้าจะไม่ต้องการให้เป็น null ต้องเป็น Employee emp = Employee();
    if(emp != null) {
        emp.showData();
    }
    // แบบสั้น 
    emp?.showData();

หลังจากที่ ใช้ quicktype แล้ว 

Joke _dataFromApi = Joke(); // สร้าง state ที่มี type เป็น Joke 
  @override
  void initState() {
    super.initState();
    getLatedExchangeRate();
  }

  Future<void> getLatedExchangeRate() async {
    var url = Uri.http(
        "official-joke-api.appspot.com", "/random_joke", {'q': '{http}'});
    var response = await http.get(url);
    print(response.body);
    _dataFromApi = jokeFromJson(response.body); // ใช้ ตัวแปรรับค่าจาก jokeFromJson ซึ่งเป็น class ที่สร้างจาก quicktype
    print(_dataFromApi.id);
    print(_dataFromApi.setup);
    print(_dataFromApi.punchline);
  }




  FutureBuilder 
    ใช้สำหรับแสดงผลหน้าจอขณะที่รอรับค่าจาก Future โดย FutureBuilder จะรอรับค่าจาก Future และแสดงผลบนหน้าจอตามที่กำหนดไว้ โดยการใช้ FutureBuilder 
    จะช่วยให้เราสามารถแสดงผลตามสถานะของ Future ได้อย่างถูกต้อง เช่น กรณีที่ Future ยังไม่เสร็จสิ้น (Future กำลังโหลดข้อมูล) หรือ Future ที่เสร็จสิ้นแล้ว (Future โหลดข้อมูลเสร็จสมบูรณ์) 
    หรือกรณีที่ Future โหลดข้อมูลไม่สำเร็จ (Future โหลดข้อมูลไม่สำเร็จ) โดยเราสามารถกำหนด Widget ที่แสดงผลในแต่ละสถานะได้ด้วยตัวเอง เช่น CircularProgressIndicator 
    หรือ Error Widget ตามที่เราต้องการแสดงผลในแต่ละสถานะของ Future นั้น ๆ
    
     Future<Joke> getJoke() async {
        var url = Uri.http(
            "official-joke-api.appspot.com", "/random_joke", {'q': '{http}'});
        var response = await http.get(url);
        _dataFromApi = jokeFromJson(response.body);
        return _dataFromApi;
    }
  
    FutureBuilder(
            future: getJoke(),
            builder: (context, snapshot) { // ถ้า if ยังไม่เป็นจริง จะให้แสดง LinearProgressIndicator() เหมือนรอค่าจาก future 
                if (snapshot.connectionState == ConnectionState.done) {
                var result = snapshot.data;
                return Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Column(
                    children: [
                        JokeDisplay(
                        id: _dataFromApi.id,
                        type: _dataFromApi.type,
                        setup: _dataFromApi.setup,
                        punchline: _dataFromApi.punchline,
                        boxHeight: 200,
                        boxColor: Colors.orange,
                        fontSize: 20,
                        fontColor: Colors.white,
                        boderRadius: 10,
                        )
                    ],
                    ),
                );
                } else {
                return LinearProgressIndicator();
                }
            },
            )